<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Malachi AI ‚Äî Puzzle Trainer</title>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <style>
    :root {
      --black:  #0a0a0a;
      --dark:   #111111;
      --panel:  #161616;
      --panel2: #1c1c1c;
      --border: #2a2a2a;
      --gold:   #c9a84c;
      --gold2:  #e8c97a;
      --cream:  #f5f0e8;
      --muted:  #6b6b6b;
      --white:  #ffffff;
      --green:  #4caf50;
      --red:    #e05068;
      --blue:   #5b8dee;
      --purple: #9c6fe4;
      --orange: #f0924a;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html { scroll-behavior: smooth; }
    body { background: var(--black); color: var(--cream); font-family: 'Outfit', sans-serif; overflow-x: hidden; min-height: 100vh; }
    .cursor { position:fixed; width:10px; height:10px; background:var(--gold); border-radius:50%; pointer-events:none; z-index:9999; transform:translate(-50%,-50%); mix-blend-mode:difference; }
    .cursor-ring { position:fixed; width:32px; height:32px; border:1px solid var(--gold); border-radius:50%; pointer-events:none; z-index:9998; transform:translate(-50%,-50%); opacity:0.4; transition:left 0.12s ease-out,top 0.12s ease-out; }
    .chess-bg { position:fixed; inset:0; z-index:0; opacity:0.025; background-image:repeating-conic-gradient(var(--gold) 0% 25%, transparent 0% 50%); background-size:48px 48px; pointer-events:none; }

    /* NAV */
    nav { position:sticky; top:0; z-index:100; display:flex; align-items:center; justify-content:space-between; padding:18px 40px; border-bottom:1px solid var(--border); background:rgba(10,10,10,0.96); backdrop-filter:blur(12px); }
    .logo { display:flex; align-items:center; gap:12px; text-decoration:none; }
    .logo-icon { display:grid; grid-template-columns:1fr 1fr; gap:2px; width:18px; height:18px; }
    .logo-icon span { background:var(--gold); border-radius:1px; display:block; }
    .logo-icon span:nth-child(2),.logo-icon span:nth-child(3) { background:transparent; border:1px solid var(--gold); }
    .logo-text { font-family:'DM Mono',monospace; font-size:13px; letter-spacing:0.1em; color:var(--cream); }
    .logo-text span { color:var(--gold); }
    .nav-right { display:flex; align-items:center; gap:16px; }
    .nav-link { font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.08em; text-transform:uppercase; color:var(--muted); text-decoration:none; padding:8px 14px; border:1px solid transparent; transition:all 0.2s; }
    .nav-link:hover, .nav-link.active { color:var(--gold); border-color:var(--border); }
    .streak-badge { font-family:'DM Mono',monospace; font-size:11px; color:var(--orange); background:rgba(240,146,74,0.1); border:1px solid rgba(240,146,74,0.3); padding:6px 12px; letter-spacing:0.08em; }

    /* MAIN LAYOUT */
    .main { position:relative; z-index:1; display:grid; grid-template-columns: 280px 1fr 300px; gap:0; min-height: calc(100vh - 65px); }

    /* LEFT SIDEBAR ‚Äî filters */
    .sidebar-left { background:var(--panel); border-right:1px solid var(--border); padding:24px 0; overflow-y:auto; }
    .sidebar-section { padding:0 20px 20px; }
    .sidebar-title { font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.2em; color:var(--muted); text-transform:uppercase; margin-bottom:12px; padding-top:20px; border-top:1px solid var(--border); }
    .sidebar-title:first-child { border-top:none; padding-top:0; }
    .filter-btn { width:100%; text-align:left; background:none; border:1px solid transparent; color:var(--muted); font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.06em; padding:9px 12px; cursor:pointer; transition:all 0.2s; display:flex; align-items:center; justify-content:space-between; margin-bottom:3px; }
    .filter-btn:hover { color:var(--cream); border-color:var(--border); }
    .filter-btn.active { color:var(--gold); background:rgba(201,168,76,0.08); border-color:rgba(201,168,76,0.3); }
    .filter-count { font-size:9px; color:var(--muted); }

    .rating-range { padding:0 4px; }
    .rating-label { display:flex; justify-content:space-between; font-family:'DM Mono',monospace; font-size:10px; color:var(--muted); margin-bottom:8px; }
    input[type=range] { width:100%; accent-color:var(--gold); }

    /* CENTER ‚Äî board */
    .board-area { display:flex; flex-direction:column; align-items:center; justify-content:center; padding:32px 24px; gap:20px; }
    .puzzle-header { width:100%; max-width:520px; display:flex; align-items:center; justify-content:space-between; }
    .puzzle-title { font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.15em; color:var(--muted); text-transform:uppercase; }
    .puzzle-rating-badge { font-family:'DM Mono',monospace; font-size:11px; color:var(--gold); background:rgba(201,168,76,0.1); border:1px solid rgba(201,168,76,0.2); padding:5px 12px; }

    .board-wrap { position:relative; }
    #board-arrows { position:absolute; inset:0; pointer-events:none; z-index:10; width:480px; height:480px; }
    .particle { position:absolute; border-radius:50%; pointer-events:none; animation:particleFly 0.6s ease-out forwards; z-index:200; }
    @keyframes particleFly { 0%{opacity:1;transform:translate(0,0) scale(1)} 100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0)} }
    #puzzle-board { display:grid; grid-template-columns:repeat(8,1fr); width:480px; height:480px; border:2px solid var(--border); box-shadow:0 0 40px rgba(0,0,0,0.6); }
    .sq { width:60px; height:60px; display:flex; align-items:center; justify-content:center; position:relative; cursor:pointer; transition:background 0.1s; }
    .sq.light { background:#f0d9b5; }
    .sq.dark  { background:#b58863; }
    .sq.selected { background:#f6f669 !important; opacity:0.9; }
    .sq.hint    { background:rgba(50,100,200,0.55) !important; }
    .sq.correct { background:#96bc4b !important; }
    .sq.wrong   { background:#e05068 !important; }
    .sq.last-from { background:rgba(246,246,105,0.5) !important; }
    .sq.last-to   { background:rgba(246,246,105,0.7) !important; }
    .sq.drag-over  { background:rgba(150,188,75,0.6) !important; }
    .piece { width:100%; height:100%; user-select:none; pointer-events:none; display:block; }
    .piece-wrap { width:85%; height:85%; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    .piece-wrap.bounce { animation:pieceBounce 0.25s cubic-bezier(0.2,0,0,1.4); }
    .piece-wrap.wrong-shake { animation:wrongShake 0.35s ease; }
    @keyframes pieceBounce { 0%{transform:scale(1.1)} 60%{transform:scale(0.95)} 100%{transform:scale(1)} }
    @keyframes wrongShake { 0%,100%{transform:translateX(0)} 20%{transform:translateX(-6px)} 40%{transform:translateX(6px)} 60%{transform:translateX(-4px)} 80%{transform:translateX(4px)} }
    .sq-label { position:absolute; bottom:2px; right:3px; font-size:8px; font-family:'DM Mono',monospace; color:rgba(0,0,0,0.35); pointer-events:none; }
    .sq-label-rank { position:absolute; top:2px; left:3px; font-size:8px; font-family:'DM Mono',monospace; color:rgba(0,0,0,0.35); pointer-events:none; }
    .move-dot { position:absolute; width:30%; height:30%; background:rgba(0,0,0,0.2); border-radius:50%; pointer-events:none; z-index:3; }
    .capture-ring { position:absolute; inset:4px; border:5px solid rgba(0,0,0,0.2); border-radius:50%; pointer-events:none; z-index:3; }

    .to-move-bar { width:480px; display:flex; align-items:center; gap:12px; font-family:'DM Mono',monospace; font-size:12px; color:var(--muted); letter-spacing:0.08em; }
    .to-move-dot { width:12px; height:12px; border-radius:50%; border:2px solid var(--border); }
    .to-move-dot.white { background:#f0f0f0; }
    .to-move-dot.black { background:#2a2a2a; border-color:#666; }

    .puzzle-controls { width:480px; display:flex; gap:10px; }
    .ctrl-btn { flex:1; padding:11px; font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.08em; text-transform:uppercase; border:1px solid var(--border); background:var(--panel); color:var(--muted); cursor:pointer; transition:all 0.2s; }
    .ctrl-btn:hover { color:var(--cream); border-color:var(--muted); }
    .ctrl-btn.primary { border-color:rgba(201,168,76,0.4); color:var(--gold); background:rgba(201,168,76,0.06); }
    .ctrl-btn.primary:hover { background:rgba(201,168,76,0.12); }

    /* FEEDBACK OVERLAY */
    .feedback-overlay { width:480px; padding:16px 20px; display:none; align-items:center; gap:14px; border:1px solid var(--border); }
    .feedback-overlay.show { display:flex; }
    .feedback-overlay.success { border-color:rgba(76,175,80,0.4); background:rgba(76,175,80,0.07); }
    .feedback-overlay.fail    { border-color:rgba(224,80,104,0.4); background:rgba(224,80,104,0.07); }
    .feedback-icon { font-size:24px; }
    .feedback-text { flex:1; }
    .feedback-title { font-weight:600; font-size:14px; margin-bottom:3px; }
    .feedback-overlay.success .feedback-title { color:var(--green); }
    .feedback-overlay.fail .feedback-title { color:var(--red); }
    .feedback-desc { font-size:12px; color:var(--muted); line-height:1.5; }

    /* RIGHT SIDEBAR ‚Äî stats + themes */
    .sidebar-right { background:var(--panel); border-left:1px solid var(--border); padding:24px 20px; overflow-y:auto; }
    .stat-row { display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px solid var(--border); }
    .stat-row:last-child { border-bottom:none; }
    .stat-label { font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.1em; color:var(--muted); text-transform:uppercase; }
    .stat-value { font-family:'DM Mono',monospace; font-size:16px; color:var(--gold); font-weight:600; }
    .stat-value.green { color:var(--green); }
    .stat-value.red { color:var(--red); }

    .themes-list { display:flex; flex-wrap:wrap; gap:6px; margin-top:12px; }
    .theme-tag { font-family:'DM Mono',monospace; font-size:9px; letter-spacing:0.08em; padding:4px 9px; background:rgba(201,168,76,0.08); border:1px solid rgba(201,168,76,0.2); color:var(--gold); text-transform:uppercase; }
    .theme-tag.blue { background:rgba(91,141,238,0.08); border-color:rgba(91,141,238,0.2); color:var(--blue); }
    .theme-tag.purple { background:rgba(156,111,228,0.08); border-color:rgba(156,111,228,0.2); color:var(--purple); }
    .theme-tag.green { background:rgba(76,175,80,0.08); border-color:rgba(76,175,80,0.2); color:var(--green); }

    .history-item { display:flex; align-items:center; gap:10px; padding:8px 0; border-bottom:1px solid var(--border); }
    .history-item:last-child { border-bottom:none; }
    .history-dot { width:8px; height:8px; border-radius:50%; flex-shrink:0; }
    .history-dot.win { background:var(--green); }
    .history-dot.loss { background:var(--red); }
    .history-info { flex:1; font-size:11px; color:var(--muted); font-family:'DM Mono',monospace; }
    .history-rating { font-family:'DM Mono',monospace; font-size:11px; color:var(--gold); }

    /* LOADING */
    .loading-state { display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; height:480px; width:480px; }
    .loading-chess { font-size:48px; animation:spin 2s linear infinite; }
    @keyframes spin { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
    .loading-text { font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.15em; color:var(--muted); text-transform:uppercase; }

    /* ERROR STATE */
    .error-state { display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; height:480px; width:480px; text-align:center; padding:40px; }
    .error-icon { font-size:48px; }
    .error-title { font-size:16px; font-weight:600; color:var(--cream); }
    .error-desc { font-size:12px; color:var(--muted); line-height:1.6; }

    .section-head { font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.2em; color:var(--muted); text-transform:uppercase; margin-bottom:14px; padding-bottom:8px; border-bottom:1px solid var(--border); }

    @media (max-width: 1100px) {
      .main { grid-template-columns: 220px 1fr; }
      .sidebar-right { display:none; }
    }
    @media (max-width: 800px) {
      .main { grid-template-columns: 1fr; }
      .sidebar-left { display:none; }
      #puzzle-board { width:360px; height:360px; }
      .sq { width:45px; height:45px; }

      .to-move-bar, .puzzle-controls, .feedback-overlay { width:360px; }
    }

    .profile-nav { display:flex; align-items:center; gap:10px; }
    .profile-avatar-btn { width:34px; height:34px; border-radius:50%; background:linear-gradient(135deg,#c9a84c,#8b6914); border:2px solid rgba(201,168,76,0.4); display:flex; align-items:center; justify-content:center; font-family:'DM Mono',monospace; font-size:12px; font-weight:700; color:#000; cursor:pointer; text-decoration:none; transition:all 0.2s; flex-shrink:0; }
    .profile-avatar-btn:hover { border-color:#c9a84c; transform:scale(1.08); }
    .profile-rating-pill { font-family:'DM Mono',monospace; font-size:10px; letter-spacing:0.08em; color:#c9a84c; background:rgba(201,168,76,0.08); border:1px solid rgba(201,168,76,0.25); padding:4px 10px; white-space:nowrap; }
    .profile-signin { font-family:'DM Mono',monospace; font-size:11px; letter-spacing:0.08em; text-transform:uppercase; color:#c9a84c; text-decoration:none; border:1px solid rgba(201,168,76,0.3); padding:6px 14px; transition:all 0.2s; }
    .profile-signin:hover { background:rgba(201,168,76,0.08); }
  </style>
</head>
<body>
<div class="cursor" id="cursor"></div>
<div class="cursor-ring" id="cursorRing"></div>
<div class="chess-bg"></div>

<nav>
  <a href="index.html" class="logo">
    <div class="logo-icon"><span></span><span></span><span></span><span></span></div>
    <div class="logo-text">Malachi <span>AI</span></div>
  </a>
  <div class="nav-right">
    <a href="index.html" class="nav-link">Home</a>
    <a href="learn.html" class="nav-link">Learn</a>
    <a href="openings.html" class="nav-link">Openings</a>
    <a href="play.html" class="nav-link">Play</a>
    <a href="dashboard.html" class="nav-link">Dashboard</a>
    <div class="streak-badge" id="streakBadge">üî• 0 Streak</div>
  </div>
</nav>

<div class="main">
  <!-- LEFT SIDEBAR -->
  <div class="sidebar-left">
    <div class="sidebar-section">
      <div class="sidebar-title">Section</div>
      <button class="filter-btn active" onclick="setSectionFilter('all',0,3000)" id="filter-all">All Puzzles <span class="filter-count">‚àû</span></button>
      <button class="filter-btn" onclick="setSectionFilter('beginner',0,400)" id="filter-beginner">Beginner</button>
      <button class="filter-btn" onclick="setSectionFilter('novice',401,800)" id="filter-novice">Novice</button>
      <button class="filter-btn" onclick="setSectionFilter('intermediate',801,1300)" id="filter-intermediate">Intermediate</button>
      <button class="filter-btn" onclick="setSectionFilter('reserve',1301,1700)" id="filter-reserve">Reserve</button>
      <button class="filter-btn" onclick="setSectionFilter('open',1701,3000)" id="filter-open">Open</button>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Tactics</div>
      <button class="filter-btn" onclick="setThemeFilter('fork')" id="filter-fork">Forks</button>
      <button class="filter-btn" onclick="setThemeFilter('pin')" id="filter-pin">Pins</button>
      <button class="filter-btn" onclick="setThemeFilter('skewer')" id="filter-skewer">Skewers</button>
      <button class="filter-btn" onclick="setThemeFilter('discoveredAttack')" id="filter-discoveredAttack">Discovered Attack</button>
      <button class="filter-btn" onclick="setThemeFilter('backRankMate')" id="filter-backRankMate">Back Rank Mate</button>
      <button class="filter-btn" onclick="setThemeFilter('mateIn1')" id="filter-mateIn1">Mate in 1</button>
      <button class="filter-btn" onclick="setThemeFilter('mateIn2')" id="filter-mateIn2">Mate in 2</button>
      <button class="filter-btn" onclick="setThemeFilter('mateIn3')" id="filter-mateIn3">Mate in 3+</button>
      <button class="filter-btn" onclick="setThemeFilter('endgame')" id="filter-endgame">Endgame</button>
      <button class="filter-btn" onclick="setThemeFilter('openingTactics')" id="filter-opening">Opening Traps</button>
      <button class="filter-btn" onclick="setThemeFilter('sacrifice')" id="filter-sacrifice">Sacrifices</button>
      <button class="filter-btn" onclick="setThemeFilter('crushing')" id="filter-crushing">Crushing</button>
    </div>
  </div>

  <!-- hidden rating inputs read by refillQueue -->
  <input type="range" id="ratingMin" min="0" max="3000" value="0" style="display:none">
  <input type="range" id="ratingMax" min="0" max="3000" value="3000" style="display:none">

  <!-- BOARD CENTER -->
  <div class="board-area">
    <div class="puzzle-header">
      <div class="puzzle-title" id="puzzleTitle">Tactics Trainer ‚Äî Powered by Lichess</div>
      <div class="puzzle-rating-badge" id="puzzleRatingBadge">Rating: ‚Äî</div>
    </div>

    <div class="board-wrap">
      <div id="puzzle-board">
        <div class="loading-state">
          <div class="loading-chess">‚ôü</div>
          <div class="loading-text">Loading puzzle...</div>
        </div>
      </div>
    </div>

    <div class="to-move-bar">
      <div class="to-move-dot" id="toMoveDot"></div>
      <span id="toMoveText">Loading...</span>
    </div>

    <div class="feedback-overlay" id="feedbackOverlay">
      <div class="feedback-icon" id="feedbackIcon"></div>
      <div class="feedback-text">
        <div class="feedback-title" id="feedbackTitle"></div>
        <div class="feedback-desc" id="feedbackDesc"></div>
      </div>
    </div>

    <div class="puzzle-controls">
      <button class="ctrl-btn" onclick="showHint()">üí° Hint</button>
      <button class="ctrl-btn" onclick="showAnswer()">üëÅ Answer</button>
      <button class="ctrl-btn" onclick="restartPuzzle()" style="color:#e8c97a;border-color:rgba(232,201,122,0.3)">üîÑ Retry</button>
      <button class="ctrl-btn primary" onclick="loadNextPuzzle()">Next ‚Üí</button>
    </div>
    <div class="puzzle-controls" style="margin-top:6px">
      <button class="ctrl-btn" id="reviewBackBtn" onclick="reviewBack()" disabled style="opacity:0.35">‚Üê Back</button>
      <button class="ctrl-btn" id="reviewLabel" style="cursor:default;flex:2;font-size:9px">Review moves</button>
      <button class="ctrl-btn" id="reviewFwdBtn" onclick="reviewForward()" disabled style="opacity:0.35">Forward ‚Üí</button>
    </div>
  </div>

  <!-- RIGHT SIDEBAR -->
  <div class="sidebar-right">
    <div class="section-head">Your Session</div>
    <div class="stat-row"><span class="stat-label">Solved</span><span class="stat-value green" id="statSolved">0</span></div>
    <div class="stat-row"><span class="stat-label">Failed</span><span class="stat-value red" id="statFailed">0</span></div>
    <div class="stat-row"><span class="stat-label">Streak</span><span class="stat-value" id="statStreak">0 üî•</span></div>
    <div class="stat-row"><span class="stat-label">Accuracy</span><span class="stat-value" id="statAccuracy">‚Äî</span></div>
    <div class="stat-row"><span class="stat-label">Best Streak</span><span class="stat-value" id="statBestStreak">0</span></div>

    <div class="section-head" style="margin-top:24px">Current Puzzle</div>
    <div style="font-family:'DM Mono',monospace;font-size:10px;color:var(--muted);margin-bottom:8px;letter-spacing:0.06em;">THEMES</div>
    <div class="themes-list" id="themesList"></div>

    <div class="section-head" style="margin-top:24px">Recent History</div>
    <div id="historyList"></div>
  </div>
</div>

<script>
// ‚îÄ‚îÄ CURSOR ‚îÄ‚îÄ
const cursor = document.getElementById('cursor');
const ring = document.getElementById('cursorRing');
document.addEventListener('mousemove', e => {
  cursor.style.left = e.clientX + 'px'; cursor.style.top = e.clientY + 'px';
  ring.style.left = e.clientX + 'px'; ring.style.top = e.clientY + 'px';
});

// ‚îÄ‚îÄ STATE ‚îÄ‚îÄ
let game = null;
let currentPuzzle = null;
let solutionMoves = [];
let solutionIndex = 0;
let selectedSquare = null;
let reviewMode = false;
let reviewMoves = [];
let reviewIndex = 0;
let puzzleSolved = false;
let puzzleFailed = false;
let hintUsed = false;
let playerColor = 'w';

let stats = { solved: 0, failed: 0, streak: 0, bestStreak: 0, history: [] };
let currentThemeFilter = 'all';
let puzzleQueue = [];
let loadingNext = false;

const SFX = {
  ctx: null,
  init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); },
  play(type) {
    try { this.init(); const ctx = this.ctx, now = ctx.currentTime, g = ctx.createGain(); g.connect(ctx.destination);
      if (type === 'move') { const o = ctx.createOscillator(); o.connect(g); o.type='triangle'; o.frequency.setValueAtTime(320,now); o.frequency.exponentialRampToValueAtTime(180,now+0.08); g.gain.setValueAtTime(0.18,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.12); o.start(now); o.stop(now+0.12); }
      else if (type === 'capture') { const o = ctx.createOscillator(); o.connect(g); o.type='sawtooth'; o.frequency.setValueAtTime(220,now); o.frequency.exponentialRampToValueAtTime(80,now+0.1); g.gain.setValueAtTime(0.25,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.15); o.start(now); o.stop(now+0.15); }
      else if (type === 'correct') { [0,0.12].forEach((d,i) => { const o=ctx.createOscillator(),gn=ctx.createGain(); o.connect(gn); gn.connect(ctx.destination); o.type='sine'; o.frequency.setValueAtTime(i===0?523:784,now+d); gn.gain.setValueAtTime(0.3,now+d); gn.gain.exponentialRampToValueAtTime(0.001,now+d+0.3); o.start(now+d); o.stop(now+d+0.3); }); }
      else if (type === 'wrong') { const o = ctx.createOscillator(); o.connect(g); o.type='sawtooth'; o.frequency.setValueAtTime(180,now); o.frequency.exponentialRampToValueAtTime(100,now+0.25); g.gain.setValueAtTime(0.2,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.28); o.start(now); o.stop(now+0.28); }
      else if (type === 'solved') { [523,659,784].forEach((freq,i) => { const o=ctx.createOscillator(),gn=ctx.createGain(); o.connect(gn); gn.connect(ctx.destination); o.type='sine'; o.frequency.setValueAtTime(freq,now+i*0.13); gn.gain.setValueAtTime(0,now+i*0.13); gn.gain.linearRampToValueAtTime(0.35,now+i*0.13+0.04); gn.gain.exponentialRampToValueAtTime(0.001,now+i*0.13+0.45); o.start(now+i*0.13); o.stop(now+i*0.13+0.5); }); }
      else if (type === 'pickup') { const o=ctx.createOscillator(); o.connect(g); o.type='sine'; o.frequency.setValueAtTime(600,now); o.frequency.exponentialRampToValueAtTime(400,now+0.04); g.gain.setValueAtTime(0.08,now); g.gain.exponentialRampToValueAtTime(0.001,now+0.05); o.start(now); o.stop(now+0.05); }
    } catch(e) {}
  }
};

const PIECE_BASE = 'https://lichess1.org/assets/piece/cburnett/';
const PIECE_SRC = {
  wK:'wK.svg', wQ:'wQ.svg', wR:'wR.svg', wB:'wB.svg', wN:'wN.svg', wP:'wP.svg',
  bK:'bK.svg', bQ:'bQ.svg', bR:'bR.svg', bB:'bB.svg', bN:'bN.svg', bP:'bP.svg'
};

const THEME_COLORS = {
  fork:'gold', pin:'blue', skewer:'purple', discoveredAttack:'blue',
  backRankMate:'red', mateIn1:'red', mateIn2:'red', mateIn3:'red',
  endgame:'green', opening:'green', sacrifice:'purple', crushing:'gold',
  short:'green', long:'purple', oneMove:'green'
};

function themeClass(t) { return THEME_COLORS[t] || ''; }

function prettyTheme(t) {
  return t.replace(/([A-Z])/g,' $1').replace(/^./,s=>s.toUpperCase()).trim();
}

// ‚îÄ‚îÄ FILTER ‚îÄ‚îÄ
// Current section rating bounds
let sectionMin = 0;
let sectionMax = 3000;

function setSectionFilter(sectionId, min, max) {
  sectionMin = min;
  sectionMax = max;
  // Update hidden sliders so refillQueue reads correct values
  document.getElementById('ratingMin').value = min;
  document.getElementById('ratingMax').value = max;
  // Clear active on ALL filter buttons, then activate this one
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('filter-' + sectionId);
  if (btn) btn.classList.add('active');
  // Also clear any active theme btn
  currentThemeFilter = 'all';
  puzzleQueue = [];
  loadNextPuzzle();
}

function setThemeFilter(theme) {
  currentThemeFilter = theme;
  document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
  const btn = document.getElementById('filter-' + theme);
  if (btn) btn.classList.add('active');
  puzzleQueue = [];
  loadNextPuzzle();
}

function updateRatingLabel() {
  // no-op ‚Äî labels removed, kept for compatibility
}

// ‚îÄ‚îÄ LICHESS API ‚îÄ‚îÄ
const SB_URL = 'https://nlsmrveieqadjmytsmjm.supabase.co';
const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5sc21ydmVpZXFhZGpteXRzbWptIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE3MTg4NjcsImV4cCI6MjA4NzI5NDg2N30.9uIWjPJsOhdXXHqGLIMcdY5eitbkGoHyhbreAEe-apM';
async function refillQueue() {
  const minR = parseInt(document.getElementById('ratingMin').value);
  const maxR = parseInt(document.getElementById('ratingMax').value);
  const base = SB_URL + '/rest/v1/puzzles';
  const hdrs = { 'apikey': SB_KEY, 'Authorization': 'Bearer ' + SB_KEY, 'Accept': 'application/json' };
  let cUrl = `${base}?select=id&rating=gte.${minR}&rating=lte.${maxR}&limit=1`;
  if (currentThemeFilter !== 'all') cUrl += `&themes=ilike.*${currentThemeFilter}*`;
  const cRes = await fetch(cUrl, { headers: { ...hdrs, 'Prefer': 'count=exact' } });
  const total = parseInt((cRes.headers.get('content-range') || '0/50000').split('/')[1]) || 50000;
  const offset = Math.floor(Math.random() * Math.max(0, total - 30));
  let url = `${base}?select=id,fen,moves,rating,themes&rating=gte.${minR}&rating=lte.${maxR}&order=id.asc&offset=${offset}&limit=30`;
  if (currentThemeFilter !== 'all') url += `&themes=ilike.*${currentThemeFilter}*`;
  const res = await fetch(url, { headers: hdrs });
  if (!res.ok) throw new Error('DB error ' + res.status);
  const data = await res.json();
  if (!data.length) throw new Error('No puzzles found for this filter.');
  for (let i = data.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [data[i],data[j]]=[data[j],data[i]]; }
  puzzleQueue = data;
}
async function loadNextPuzzle() {
  puzzleSolved = false; puzzleFailed = false; hintUsed = false; selectedSquare = null;
  reviewMode = false; reviewMoves = []; reviewIndex = 0;
  document.getElementById('feedbackOverlay').className = 'feedback-overlay';
  document.getElementById('toMoveText').textContent = 'Loading...';
  document.getElementById('puzzleRatingBadge').textContent = 'Rating: ‚Äî';
  document.getElementById('themesList').innerHTML = '';
  document.getElementById('puzzle-board').innerHTML = '<div class="loading-state"><div class="loading-chess">‚ôü</div><div class="loading-text">Loading puzzle...</div></div>';
  try {
    if (puzzleQueue.length === 0) await refillQueue();
    const p = puzzleQueue.shift();
    currentPuzzle = { id:p.id, fen:p.fen, moves:p.moves, rating:p.rating, themes:(p.themes||'').split(' ').filter(Boolean) };
    setupPuzzle({ puzzle: currentPuzzle });
  } catch(e) { showError(e); }
}

function setupPuzzle(data) {
  const puzzle = data.puzzle;
  const fen = puzzle.fen;
  const movesUCI = puzzle.moves.split(' '); // all moves: first is opponent's setup move, rest are solution

  game = new Chess(fen);

  // Play the first move (opponent's move that sets up the puzzle)
  const setupMove = movesUCI[0];
  const from = setupMove.slice(0,2);
  const to = setupMove.slice(2,4);
  const promo = setupMove[4] || undefined;
  game.move({ from, to, promotion: promo });

  // Solution is everything after the first move
  solutionMoves = movesUCI.slice(1);
  solutionIndex = 0;
  playerColor = game.turn(); // whoever moves next is the player

  // Update header
  const rating = puzzle.rating || '?';
  document.getElementById('puzzleRatingBadge').textContent = 'Rating: ' + rating;
  document.getElementById('puzzleTitle').textContent = 'Find the best move ‚Äî ' + (playerColor === 'w' ? 'White' : 'Black') + ' to move';

  // Themes
  const themes = (puzzle.themes || []);
  const themeHtml = themes.slice(0,8).map(t =>
    `<span class="theme-tag ${themeClass(t)}">${prettyTheme(t)}</span>`
  ).join('');
  document.getElementById('themesList').innerHTML = themeHtml;

  renderBoard();
  updateToMove();
  animateSetupMove(from, to);
}

function animateSetupMove(from, to) {
  // Briefly highlight the setup move squares
  setTimeout(() => {
    const fromEl = document.querySelector(`[data-sq="${from}"]`);
    const toEl = document.querySelector(`[data-sq="${to}"]`);
    if (fromEl) fromEl.classList.add('last-from');
    if (toEl) toEl.classList.add('last-to');
    setTimeout(() => {
      if (fromEl) fromEl.classList.remove('last-from');
      if (toEl) toEl.classList.remove('last-to');
    }, 800);
  }, 100);
}

// ‚îÄ‚îÄ BOARD RENDERING ‚îÄ‚îÄ
function renderBoard() {
  const board = document.getElementById('puzzle-board');
  board.innerHTML = '';
  const pos = game.board();

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const rank = playerColor === 'w' ? 7 - r : r;
      const file = playerColor === 'w' ? c : 7 - c;
      const sq = 'abcdefgh'[file] + (rank + 1);
      // chess.js pos[0]=rank8, pos[7]=rank1 so arrayRow=r for white, 7-r for black
      const arrayRow = playerColor === 'w' ? r : 7 - r;
      const piece = pos[arrayRow] ? pos[arrayRow][file] : null;
      const isLight = (rank + file) % 2 === 1;

      const div = document.createElement('div');
      div.className = 'sq ' + (isLight ? 'light' : 'dark');
      div.dataset.sq = sq;
      div.onclick = () => handleSquareClick(sq);

      if (piece) {
        const key = piece.color + piece.type.toUpperCase();
        const wrap = document.createElement('div');
        wrap.className = 'piece-wrap';
        wrap.dataset.sq = sq;
        const img = document.createElement('img');
        img.src = PIECE_BASE + PIECE_SRC[key];
        img.className = 'piece';
        img.draggable = false;
        wrap.appendChild(img);
        wrap.addEventListener('mousedown', e => startDrag(e, sq));
        wrap.addEventListener('touchstart', e => startDrag(e, sq), { passive: true });
        div.appendChild(wrap);
      }

      if (c === 0) {
        const lbl = document.createElement('div');
        lbl.className = 'sq-label-rank';
        lbl.textContent = rank + 1;
        div.appendChild(lbl);
      }
      if (r === 7) {
        const lbl = document.createElement('div');
        lbl.className = 'sq-label';
        lbl.textContent = 'abcdefgh'[file];
        div.appendChild(lbl);
      }

      board.appendChild(div);
    }
  }

  if (selectedSquare && !puzzleSolved && !puzzleFailed) {
    const moves = game.moves({ square: selectedSquare, verbose: true });
    moves.forEach(m => {
      const toEl = document.querySelector(`[data-sq="${m.to}"]`);
      if (!toEl) return;
      const targetPiece = game.get(m.to);
      if (targetPiece) {
        const ring = document.createElement('div'); ring.className = 'capture-ring'; toEl.appendChild(ring);
      } else {
        const dot = document.createElement('div'); dot.className = 'move-dot'; toEl.appendChild(dot);
      }
    });
    const selEl = document.querySelector(`[data-sq="${selectedSquare}"]`);
    if (selEl) selEl.classList.add('selected');
  }
  clearArrows();
}

// ‚îÄ‚îÄ DRAG & DROP ‚îÄ‚îÄ
let dragSq = null, dragEl = null, dragClone = null;
function startDrag(e, sq) {
  if (puzzleSolved || puzzleFailed) return;
  if (game.turn() !== playerColor) return;
  const piece = game.get(sq);
  if (!piece || piece.color !== playerColor) return;
  SFX.play('pickup');
  selectedSquare = sq; renderBoard();
  dragSq = sq;
  dragEl = document.querySelector(`.piece-wrap[data-sq="${sq}"]`);
  dragClone = dragEl.cloneNode(true);
  dragClone.style.cssText = 'position:fixed;width:72px;height:72px;pointer-events:none;z-index:1000;transform:translate(-50%,-50%) scale(1.2);filter:drop-shadow(0 8px 20px rgba(0,0,0,0.6));transition:none;';
  document.body.appendChild(dragClone);
  const pos = getEvPos(e);
  dragClone.style.left = pos.x + 'px'; dragClone.style.top = pos.y + 'px';
  if (dragEl) dragEl.style.opacity = '0.3';
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);
  document.addEventListener('touchmove', onDragMove, { passive: true });
  document.addEventListener('touchend', onDragEnd);
}
function getEvPos(e) {
  if (e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
  return { x: e.clientX, y: e.clientY };
}
function onDragMove(e) {
  if (!dragClone) return;
  const pos = getEvPos(e);
  dragClone.style.left = pos.x + 'px'; dragClone.style.top = pos.y + 'px';
  document.querySelectorAll('.sq.drag-over').forEach(el => el.classList.remove('drag-over'));
  const el = document.elementFromPoint(pos.x, pos.y);
  const sq = el?.closest?.('[data-sq]')?.dataset?.sq || el?.dataset?.sq;
  if (sq && sq !== dragSq) { const sqEl = document.querySelector(`.sq[data-sq="${sq}"]`); if (sqEl) sqEl.classList.add('drag-over'); }
}
function onDragEnd(e) {
  document.removeEventListener('mousemove', onDragMove); document.removeEventListener('mouseup', onDragEnd);
  document.removeEventListener('touchmove', onDragMove); document.removeEventListener('touchend', onDragEnd);
  if (!dragClone) return;
  const pos = getEvPos(e.changedTouches ? e : e);
  const el = document.elementFromPoint(pos.x, pos.y);
  const toSq = el?.closest?.('[data-sq]')?.dataset?.sq || el?.dataset?.sq;
  document.querySelectorAll('.sq.drag-over').forEach(el => el.classList.remove('drag-over'));
  if (dragClone) { dragClone.remove(); dragClone = null; }
  if (dragEl) { dragEl.style.opacity = ''; dragEl = null; }
  if (toSq && toSq !== dragSq) { attemptMove(dragSq, toSq); selectedSquare = null; renderBoard(); }
  else renderBoard();
  dragSq = null;
}

// ‚îÄ‚îÄ ARROWS & PARTICLES ‚îÄ‚îÄ
function clearArrows() { const s = document.getElementById('board-arrows'); if (s) s.innerHTML = ''; }
function drawArrow(fromSq, toSq, color='#ff4444') {
  const svg = document.getElementById('board-arrows'); if (!svg) return;
  const SQ = 60;
  function sqXY(sq) {
    const file = 'abcdefgh'.indexOf(sq[0]), rank = parseInt(sq[1]) - 1;
    const col = playerColor === 'w' ? file : 7 - file;
    const row = playerColor === 'w' ? 7 - rank : rank;
    return { x: col*SQ + SQ/2, y: row*SQ + SQ/2 };
  }
  const f = sqXY(fromSq), t = sqXY(toSq);
  const dx = t.x-f.x, dy = t.y-f.y, len = Math.sqrt(dx*dx+dy*dy);
  const ux = dx/len, uy = dy/len;
  const id = 'a' + Math.random().toString(36).slice(2);
  svg.innerHTML += `<defs><marker id="${id}" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6 Z" fill="${color}" opacity="0.85"/></marker></defs><line x1="${f.x+ux*12}" y1="${f.y+uy*12}" x2="${t.x-ux*18}" y2="${t.y-uy*18}" stroke="${color}" stroke-width="9" stroke-linecap="round" marker-end="url(#${id})" opacity="0.82"/>`;
}
function spawnParticles(sq, color) {
  const sqEl = document.querySelector(`.sq[data-sq="${sq}"]`); if (!sqEl) return;
  const rect = sqEl.getBoundingClientRect();
  const cx = rect.left + rect.width/2, cy = rect.top + rect.height/2;
  for (let i = 0; i < 10; i++) {
    const p = document.createElement('div'); p.className = 'particle';
    const angle = (i/10)*Math.PI*2, dist = 30 + Math.random()*30;
    p.style.cssText = `left:${cx}px;top:${cy}px;width:${4+Math.random()*5}px;height:${4+Math.random()*5}px;background:${color};--dx:${Math.cos(angle)*dist}px;--dy:${Math.sin(angle)*dist}px;`;
    document.body.appendChild(p); setTimeout(() => p.remove(), 650);
  }
}

function updateToMove() {
  const dot = document.getElementById('toMoveDot');
  const txt = document.getElementById('toMoveText');
  dot.className = 'to-move-dot ' + (playerColor === 'w' ? 'white' : 'black');
  txt.textContent = 'You are ' + (playerColor === 'w' ? 'White' : 'Black') + ' ‚Äî find the best move!';
}

// ‚îÄ‚îÄ MOVE HANDLING ‚îÄ‚îÄ
function handleSquareClick(sq) {
  if (puzzleSolved || puzzleFailed) return;
  if (game.turn() !== playerColor) return;

  const piece = game.get(sq);

  if (selectedSquare) {
    if (selectedSquare === sq) {
      selectedSquare = null;
      renderBoard();
      return;
    }
    // Try the move
    const move = attemptMove(selectedSquare, sq);
    if (move) {
      selectedSquare = null;
      return;
    }
    // If clicked own piece, select it instead
    if (piece && piece.color === playerColor) {
      selectedSquare = sq;
      renderBoard();
      return;
    }
    selectedSquare = null;
    renderBoard();
    return;
  }

  if (piece && piece.color === playerColor) {
    selectedSquare = sq;
    renderBoard();
  }
}

function attemptMove(from, to) {
  const promotion = needsPromotion(from, to) ? 'q' : undefined;
  const move = game.move({ from, to, promotion });
  if (!move) return null;

  // Check if move matches solution
  const expected = solutionMoves[solutionIndex];
  const expectedFrom = expected.slice(0,2);
  const expectedTo = expected.slice(2,4);
  const playerMoveUCI = from + to + (promotion || '');
  const expectedUCI = expected.slice(0,4) + (expected[4] || '');

  SFX.play(move.captured ? 'capture' : 'move');

  if (from === expectedFrom && to === expectedTo) {
    flashSquares(from, to, 'correct');
    SFX.play('correct');
    spawnParticles(to, '#96bc4b');
    solutionIndex++;
    if (solutionIndex >= solutionMoves.length) {
      onPuzzleSolved();
    } else {
      renderBoard();
      setTimeout(() => playOpponentMove(), 750);
    }
  } else {
    game.undo();
    flashSquares(from, to, 'wrong');
    SFX.play('wrong');
    setTimeout(() => { drawArrow(expectedFrom, expectedTo, '#ff4444'); setTimeout(clearArrows, 2000); }, 300);
    onPuzzleFailed(from, to);
  }

  renderBoard();
  return move;
}

function playOpponentMove() {
  if (solutionIndex >= solutionMoves.length) return;
  const oppMove = solutionMoves[solutionIndex];
  const from = oppMove.slice(0,2);
  const to = oppMove.slice(2,4);
  const promo = oppMove[4] || undefined;
  game.move({ from, to, promotion: promo });
  solutionIndex++;
  flashSquares(from, to, 'last-from');
  renderBoard();
  if (solutionIndex >= solutionMoves.length) {
    onPuzzleSolved();
  }
}

function needsPromotion(from, to) {
  const piece = game.get(from);
  if (!piece || piece.type !== 'p') return false;
  const toRank = parseInt(to[1]);
  return (piece.color === 'w' && toRank === 8) || (piece.color === 'b' && toRank === 1);
}

function flashSquares(from, to, cls) {
  const fromEl = document.querySelector(`[data-sq="${from}"]`);
  const toEl = document.querySelector(`[data-sq="${to}"]`);
  if (fromEl) { fromEl.classList.add(cls); setTimeout(() => fromEl.classList.remove(cls), 700); }
  if (toEl)   { toEl.classList.add(cls);   setTimeout(() => toEl.classList.remove(cls), 700); }
}

// ‚îÄ‚îÄ PUZZLE OUTCOME ‚îÄ‚îÄ
function onPuzzleSolved() {
  puzzleSolved = true;
  setTimeout(enterReviewMode, 600);
  setTimeout(() => { SFX.play('solved'); spawnParticles('e4','#f6c744'); spawnParticles('d5','#96bc4b'); }, 200);
  stats.solved++;
  stats.streak++;
  if (stats.streak > stats.bestStreak) stats.bestStreak = stats.streak;
  addHistory(currentPuzzle?.rating || '?', true);
  updateStats();

  const overlay = document.getElementById('feedbackOverlay');
  overlay.className = 'feedback-overlay show success';
  document.getElementById('feedbackIcon').textContent = hintUsed ? '‚úì' : '‚≠ê';
  document.getElementById('feedbackTitle').textContent = hintUsed ? 'Solved with hint!' : 'Brilliant! Puzzle solved!';
  document.getElementById('feedbackDesc').textContent = hintUsed
    ? 'You found the right idea. Try the next one without a hint!'
    : 'You found the best move. Keep going ‚Äî your tactics are improving!';
}

function onPuzzleFailed(from, to) {
  puzzleFailed = true;
  stats.failed++;
  stats.streak = 0;
  addHistory(currentPuzzle?.rating || '?', false);
  updateStats();

  const overlay = document.getElementById('feedbackOverlay');
  overlay.className = 'feedback-overlay show fail';
  document.getElementById('feedbackIcon').textContent = '‚úó';
  document.getElementById('feedbackTitle').textContent = 'Not the best move';
  const expected = solutionMoves[solutionIndex];
  const solFrom = expected.slice(0,2).toUpperCase();
  const solTo = expected.slice(2,4).toUpperCase();
  setTimeout(enterReviewMode, 1200);
  const tempGame = new Chess(game.fen());
  const solMove = tempGame.move({ from: expected.slice(0,2), to: expected.slice(2,4), promotion: expected[4] || 'q' });
  const sanMove = solMove ? solMove.san : expected.slice(0,4);
  document.getElementById('feedbackDesc').textContent = `The right move was ${sanMove}. Hit Retry to try again.`;
}

function updateReviewBtns() {
  const back = document.getElementById('reviewBackBtn');
  const fwd  = document.getElementById('reviewFwdBtn');
  const lbl  = document.getElementById('reviewLabel');
  if (!back) return;
  back.disabled = !(reviewMode && reviewIndex > 0);
  back.style.opacity = (reviewMode && reviewIndex > 0) ? '1' : '0.35';
  fwd.disabled = !(reviewMode && reviewIndex < reviewMoves.length);
  fwd.style.opacity = (reviewMode && reviewIndex < reviewMoves.length) ? '1' : '0.35';
  lbl.textContent = reviewMode ? 'Move ' + reviewIndex + ' / ' + reviewMoves.length : 'Review moves';
}
function enterReviewMode() {
  reviewMoves = game.history({ verbose: true });
  reviewIndex = reviewMoves.length;
  reviewMode = true;
  updateReviewBtns();
}
function reviewBack() {
  if (!reviewMode || reviewIndex <= 0) return;
  reviewIndex--;
  const g = new Chess(currentPuzzle.fen);
  const su = currentPuzzle.moves.split(' ')[0];
  g.move({ from: su.slice(0,2), to: su.slice(2,4), promotion: su[4] || 'q' });
  for (let i = 0; i < reviewIndex; i++) g.move(reviewMoves[i].san);
  game = g; renderBoard(); updateReviewBtns();
}
function reviewForward() {
  if (!reviewMode || reviewIndex >= reviewMoves.length) return;
  game.move(reviewMoves[reviewIndex].san);
  reviewIndex++; renderBoard(); updateReviewBtns();
}
function restartPuzzle() {
  if (!currentPuzzle) return;
  puzzleSolved = false; puzzleFailed = false; hintUsed = false; selectedSquare = null;
  reviewMode = false; reviewMoves = []; reviewIndex = 0;
  clearArrows(); updateReviewBtns();
  document.getElementById('feedbackOverlay').className = 'feedback-overlay';
  document.getElementById('themesList').innerHTML = '';
  setupPuzzle({ puzzle: currentPuzzle });
}
function showAnswer() {
  if (puzzleSolved || puzzleFailed) return;
  puzzleFailed = true;
  addHistory(currentPuzzle.rating, false);
  stats.failed++; stats.streak = 0; updateStats();
  const overlay = document.getElementById('feedbackOverlay');
  overlay.className = 'feedback-overlay show fail';
  document.getElementById('feedbackIcon').textContent = 'üí°';
  document.getElementById('feedbackTitle').textContent = 'Showing solution...';
  document.getElementById('feedbackDesc').textContent = '';
  let idx = solutionIndex;
  function step() {
    if (idx >= solutionMoves.length) {
      document.getElementById('feedbackTitle').textContent = 'Solution complete';
      document.getElementById('feedbackDesc').textContent = 'Use ‚Üê ‚Üí to review the moves.';
      enterReviewMode(); return;
    }
    const uci = solutionMoves[idx], from = uci.slice(0,2), to = uci.slice(2,4), promo = uci[4]||'q';
    const fromEl = document.querySelector('.sq[data-sq="' + from + '"]');
    if (fromEl) fromEl.classList.add('hint');
    setTimeout(() => {
      if (fromEl) fromEl.classList.remove('hint');
      const m = game.move({ from, to, promotion: promo });
      SFX.play(m && m.captured ? 'capture' : 'move');
      flashSquares(from, to, 'last-to');
      renderBoard(); idx++; setTimeout(step, 800);
    }, 500);
  }
  step();
}
function showHint() {
  if (puzzleSolved || puzzleFailed || solutionIndex >= solutionMoves.length) return;
  hintUsed = true;
  const expected = solutionMoves[solutionIndex];
  const hintFrom = expected.slice(0,2);
  const hintEl = document.querySelector(`[data-sq="${hintFrom}"]`);
  if (hintEl) {
    hintEl.classList.add('hint');
    setTimeout(() => hintEl.classList.remove('hint'), 1500);
  }
  selectedSquare = hintFrom;
  renderBoard();
}

function skipPuzzle() {
  stats.failed++;
  stats.streak = 0;
  addHistory(currentPuzzle?.rating || '?', false);
  updateStats();
  loadNextPuzzle();
}

// ‚îÄ‚îÄ STATS ‚îÄ‚îÄ
function updateStats() {
  document.getElementById('statSolved').textContent = stats.solved;
  document.getElementById('statFailed').textContent = stats.failed;
  document.getElementById('statStreak').textContent = stats.streak + ' üî•';
  document.getElementById('statBestStreak').textContent = stats.bestStreak;
  document.getElementById('streakBadge').textContent = 'üî• ' + stats.streak + ' Streak';
  const total = stats.solved + stats.failed;
  const acc = total > 0 ? Math.round(stats.solved / total * 100) + '%' : '‚Äî';
  document.getElementById('statAccuracy').textContent = acc;
}

function addHistory(rating, won) {
  stats.history.unshift({ rating, won });
  if (stats.history.length > 8) stats.history.pop();
  const list = document.getElementById('historyList');
  list.innerHTML = stats.history.map(h => `
    <div class="history-item">
      <div class="history-dot ${h.won ? 'win' : 'loss'}"></div>
      <div class="history-info">${h.won ? 'Solved' : 'Failed'}</div>
      <div class="history-rating">${h.rating}</div>
    </div>`).join('');
}

function showError(err) {
  document.getElementById('puzzle-board').innerHTML = `
    <div class="error-state">
      <div class="error-icon">‚ö†Ô∏è</div>
      <div class="error-title">Couldn't load puzzle</div>
      <div class="error-desc">The Lichess API is unreachable. Check your internet connection and try again.<br><br>Error: ${err.message}</div>
    </div>`;
  document.getElementById('toMoveText').textContent = 'Connection error';
}

// ‚îÄ‚îÄ INIT ‚îÄ‚îÄ
loadNextPuzzle();
updateStats();
</script>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
(function() {
  const SB_URL = 'https://nlsmrveieqadjmytsmjm.supabase.co';
  const SB_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5sc21ydmVpZXFhZGpteXRzbWptIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE3MTg4NjcsImV4cCI6MjA4NzI5NDg2N30.9uIWjPJsOhdXXHqGLIMcdY5eitbkGoHyhbreAEe-apM';
  function tryInject() {
    if (!window.supabase) { setTimeout(tryInject, 50); return; }
    const _sb = window.supabase.createClient(SB_URL, SB_KEY, { auth: { persistSession:true, storageKey:'malachi-auth' } });
    _sb.auth.getSession().then(({ data: { session } }) => {
      const container = document.querySelector('.nav-right');
      if (!container) return;
      const widget = document.createElement('div');
      widget.className = 'profile-nav';
      if (session) {
        _sb.from('profiles').select('username,chess_rating').eq('id', session.user.id).single().then(({ data: profile }) => {
          const initials = (profile?.username||'?').split(' ').map(n=>n[0]).join('').toUpperCase().slice(0,2);
          const rating = profile?.chess_rating;
          if (rating) {
            const pill = document.createElement('div'); pill.className='profile-rating-pill';
            pill.textContent='‚ôü '+rating; widget.appendChild(pill);
          }
          const avatar = document.createElement('a'); avatar.href='profile.html';
          avatar.className='profile-avatar-btn'; avatar.title='My Profile';
          avatar.textContent=initials; widget.appendChild(avatar);
          container.appendChild(widget);
        });
      } else {
        const signin = document.createElement('a'); signin.href='login.html';
        signin.className='profile-signin'; signin.textContent='Sign In';
        widget.appendChild(signin); container.appendChild(widget);
      }
    });
  }
  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', tryInject);
  else tryInject();
})();
</script>
</body>
</html>
